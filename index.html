<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamFlow - Elastic Partition System with Consistent Hashing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #050505;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 3.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-weight: 800;
        }

        .subtitle {
            color: #888;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .tech-info {
            color: #00ff88;
            font-size: 1.1em;
            font-family: 'Courier New', monospace;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .panel-content {
            position: relative;
            z-index: 1;
        }

        .panel-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #ff6b6b, #ff5252);
        }

        button.success {
            background: linear-gradient(135deg, #00ff88, #00cc70);
        }

        button.warning {
            background: linear-gradient(135deg, #ffd93d, #ff9800);
        }

        #consistent-hash-ring {
            width: 400px;
            height: 400px;
            margin: 0 auto;
            position: relative;
        }

        .hash-ring {
            width: 100%;
            height: 100%;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            position: absolute;
            background: radial-gradient(circle at center, rgba(102, 126, 234, 0.05) 0%, transparent 70%);
        }

        /* Message Flow Indicator */
        #message-flow-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            transform-origin: center center;
        }

        #message-flow-indicator.active {
            opacity: 1;
            animation: flowPulse 0.5s infinite alternate;
        }

        @keyframes flowPulse {
            from { transform: translate(-50%, -50%) scale(1); opacity: 1;}
            to { transform: translate(-50%, -50%) scale(1.05); opacity: 0.8;}
        }

        #message-flow-arrow {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #00ff88;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            filter: drop-shadow(0 0 5px rgba(0, 255, 136, 0.7));
            animation: arrowGlow 1s infinite alternate;
        }

        @keyframes arrowGlow {
            from { filter: drop-shadow(0 0 5px rgba(0, 255, 136, 0.7)); }
            to { filter: drop-shadow(0 0 15px rgba(0, 255, 136, 1)); }
        }

        .slot-node {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .slot-node.active {
            background: linear-gradient(135deg, #00ff88, #00cc70);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }

        .slot-node.inactive {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
        }

        .slot-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
            border-color: #00ff88;
        }

        .slot-node.migrating-flash {
            animation: migrateFlash 0.6s ease-in-out;
        }

        @keyframes migrateFlash {
            0% { background: #ffd93d; transform: scale(1.2); }
            50% { background: #ff9800; transform: scale(0.8); }
            100% { background: linear-gradient(135deg, #00ff88, #00cc70); transform: scale(1); }
        }

        .partition-node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 15;
        }

        .partition-node.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 0 25px rgba(102, 126, 234, 0.6);
            animation: pulse 2s infinite;
        }

        .partition-node.highlight-pulse {
            animation: partitionHighlightPulse 0.6s ease-out;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.8), 0 0 20px rgba(102, 126, 234, 0.8);
        }

        @keyframes partitionHighlightPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(0, 255, 136, 0.8), 0 0 20px rgba(102, 126, 234, 0.8); }
            100% { transform: scale(1); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .partition-node.migrating {
            background: linear-gradient(135deg, #ffd93d, #ff9800);
            animation: migrate 1s ease-in-out;
        }

        @keyframes migrate {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        .mapping-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.6), transparent);
            height: 2px;
            transform-origin: left center;
            transition: all 0.5s ease;
            z-index: 5;
        }

        .slot-details {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .slot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .slot-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .slot-card:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
        }

        .slot-card.highlighted {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }

        .metric-label {
            color: #888;
        }

        .metric-value {
            font-weight: bold;
            color: #00ff88;
            font-size: 1.2em;
        }

        #partition-distribution {
            height: 300px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .distribution-bar {
            position: absolute;
            bottom: 0;
            width: 30px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 5px 5px 0 0;
            transition: all 0.5s ease;
            cursor: pointer;
        }

        .distribution-bar:hover {
            opacity: 0.8;
            transform: scaleY(1.05);
        }

        .log-container {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 5px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .log-entry.info {
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .log-entry.success {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }

        .log-entry.warning {
            background: rgba(255, 215, 61, 0.1);
            border-left: 3px solid #ffd93d;
        }

        .log-entry.error {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
        }

        .timestamp {
            color: #666;
            font-size: 0.9em;
        }

        /* Hash Test Panel */
        .hash-test-panel {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .hash-test-input {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }

        .hash-test-result {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }

        /* Migration Visualization */
        .migration-info {
            background: rgba(255, 215, 61, 0.1);
            border: 1px solid rgba(255, 215, 61, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }

        .migration-info.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Step-by-Step Mode */
        .step-controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .step-info {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        /* Stats Chart */
        .stats-chart {
            height: 200px;
            margin-top: 20px;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
        }

        .stats-line {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: #00ff88;
            transition: height 0.3s ease;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            border: 1px solid rgba(102, 126, 234, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            float: right;
            font-size: 30px;
            cursor: pointer;
            color: #666;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #ff6b6b;
        }

        /* Info Tooltip */
        .info-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #050505;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            white-space: nowrap;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, 10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            left: 50%;
            bottom: calc(100% + 10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .info-tooltip.info { background: #e0e7ff; color: #333; }
        .info-tooltip.success { background: #d0ffed; color: #333; }
        .info-tooltip.warning { background: #fffde0; color: #333; }
        .info-tooltip.error { background: #ffdada; color: #333; }

        .info-tooltip.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Tutorial Overlay */
        #tutorialOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            text-align: center;
            color: #e0e0e0;
            cursor: pointer; /* Make entire overlay clickable */
        }

        #tutorialContent {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px; /* Reduced from 700px */
            width: 90%;
            border: 1px solid rgba(102, 126, 234, 0.5);
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
            position: relative;
            cursor: auto; /* Prevent closing when clicking content */
        }

        #tutorialContent h2 {
            font-size: 2em; /* Reduced from 2.5em */
            background: linear-gradient(135deg, #00ff88, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }

        #tutorialContent p {
            font-size: 1em; /* Reduced from 1.2em */
            margin-bottom: 10px;
            line-height: 1.4;
            color: #ccc;
        }

        #tutorialContent .highlight-text {
            color: #00ff88;
            font-weight: bold;
        }

        #tutorialContent .tutorial-step {
            margin-bottom: 15px; /* Reduced from 25px */
            padding: 10px; /* Reduced from 15px */
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            text-align: left;
            transition: background 0.3s ease;
            font-size: 0.9em; /* Slightly smaller text */
        }

        #tutorialContent .tutorial-step strong {
            color: #667eea;
            font-size: 1em; /* Reduced from 1.1em */
        }
        
        #tutorialContent button {
            margin-top: 15px;
            background: linear-gradient(135deg, #00ff88, #00cc70);
            padding: 12px 25px; /* Reduced from 15px 30px */
            border-radius: 12px;
            font-size: 16px;
        }

        #tutorialContent button:hover {
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
        }

        /* Close hint */
        .close-hint {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #666;
            font-size: 0.9em;
            font-style: italic;
        }

        /* Speed Control Styling */
        .speed-control {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 20px;
            border-radius: 10px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        .speed-control label {
            color: #667eea;
            font-weight: 600;
        }

        .speed-control input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #764ba2;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: 2px solid #00cc70;
            box-shadow: 0 0 5px rgba(0, 255, 136, 0.6);
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: 2px solid #00cc70;
            box-shadow: 0 0 5px rgba(0, 255, 136, 0.6);
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            #consistent-hash-ring {
                width: 300px;
                height: 300px;
            }

            h1 {
                font-size: 2.5em;
            }

            .subtitle {
                font-size: 1em;
            }

            .tech-info {
                font-size: 0.9em;
            }

            .speed-control {
                width: 100%;
                justify-content: center;
                padding: 10px;
            }

            .speed-control input[type="range"] {
                width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>StreamFlow</h1>
            <p class="subtitle">Elastic Partition System</p>
            <p class="tech-info">Consistent Hashing ‚Ä¢ Slot-Based Mapping ‚Ä¢ Zero-Downtime Scaling</p>
        </header>

        <div class="controls">
            <button id="addPartitionBtn" onclick="addPartition()" class="success">‚ûï Add Partition</button>
            <button id="removePartitionBtn" onclick="removePartition()" class="danger">‚ûñ Remove Partition</button>
            <button id="rebalanceBtn" onclick="rebalanceSlots()">üîÑ Rebalance Slots</button>
            <button id="simulateLoadBtn" onclick="simulateLoad()">üìä Auto-Scaling Demo</button>
            <button onclick="toggleAnimation()">‚èØÔ∏è Animation</button>
            <button onclick="showSystemInfo()">‚ÑπÔ∏è System Info</button>
            <button onclick="toggleStepMode()" class="warning">üéØ Step Mode</button>
            <button onclick="showHashTest()">üîç Test Hash</button>
            <div id="infoTooltip" class="info-tooltip"></div>
        </div>

        <div class="speed-control">
            <label for="simulationSpeed">Execution Speed:</label>
            <input type="range" id="simulationSpeed" min="50" max="2000" value="200" step="50" oninput="setSimulationSpeed(this.value)">
            <span id="speedValue">1x</span>
        </div>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-content">
                    <h3 class="panel-title">Consistent Hash Ring</h3>
                    <div id="consistent-hash-ring">
                        <div class="hash-ring"></div>
                        <div id="message-flow-indicator">
                            <div id="message-flow-arrow"></div>
                        </div>
                    </div>
                    
                    <div class="slot-details">
                        <h4 style="margin-bottom: 10px;">Slot Details</h4>
                        <div class="metric">
                            <span class="metric-label">Total Slots</span>
                            <span class="metric-value" id="total-slots">16</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Active Partitions</span>
                            <span class="metric-value" id="active-partitions">4</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Replication Factor</span>
                            <span class="metric-value" id="replication-factor">3</span>
                        </div>
                    </div>
                    
                    <div id="migrationInfo" class="migration-info">
                        <h4 style="color: #ffd93d;">üîÑ Migration in Progress</h4>
                        <div id="migrationDetails"></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-content">
                    <h3 class="panel-title">Partition Distribution</h3>
                    <div id="partition-distribution"></div>
                    
                    <div class="slot-grid" id="slot-grid"></div>
                    
                    <div class="stats-chart" id="statsChart">
                        <h4 style="margin-bottom: 10px; color: #667eea;">Load Distribution History</h4>
                        <div id="chartContainer" style="position: relative; height: 150px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-content">
                <h3 class="panel-title">Operation Log</h3>
                <div class="log-container" id="log-container">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> System initialized with 16 slots and 2 partitions
                    </div>
                </div>
                
                <div id="stepControls" class="step-controls" style="display: none;">
                    <div class="step-info">Step-by-Step Mode Active</div>
                    <button onclick="nextStep()">Next Step ‚û°Ô∏è</button>
                    <button onclick="autoPlay()">Auto Play ‚ñ∂Ô∏è</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-content">
                <h3 class="panel-title">Interactive Hash Testing</h3>
                <div class="hash-test-panel">
                    <input type="text" id="hashTestInput" class="hash-test-input" placeholder="Enter a message key to test (e.g., user_123, order_456)" />
                    <button onclick="testHash()">Test Hash ‚Üí</button>
                    <div id="hashTestResult" class="hash-test-result" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle">System Information</h2>
            <div id="modalBody"></div>
        </div>
    </div>

    <div id="tutorialOverlay" onclick="hideTutorial(event)">
        <div id="tutorialContent" onclick="event.stopPropagation()">
            <span class="close-hint">Click anywhere outside to close</span>
            <h2>Welcome to StreamFlow!</h2>
            <p>Understand <span class="highlight-text">Streamflow's Consistent Hashing</span> and <span class="highlight-text">Elastic Partitioning</span> through interactive visualization.</p>
            <div class="tutorial-step">
                <strong>Hash Ring:</strong> The circle represents the hash space where messages are mapped.
            </div>
            <div class="tutorial-step">
                <strong>Slots (S0-S15):</strong> Fixed points that receive messages based on their hash.
            </div>
            <div class="tutorial-step">
                <strong>Partitions (P1, P2...):</strong> Physical servers managing groups of slots.
            </div>
            <div class="tutorial-step">
                <strong>Try:</strong> Test Hash, Add/Remove Partitions, and Auto-Scaling Demo!
            </div>
            <button onclick="hideTutorial(event)">Start Exploring</button>
        </div>
    </div>

    <script>
        // Configuration du syst√®me
        const TOTAL_SLOTS = 16;
        const HASH_SPACE = 360;
        let partitions = [];
        let slots = [];
        let slotToPartitionMap = {};
        let animationRunning = true;
        let nextPartitionId = 1;
        let loadSimulationInterval = null;
        let currentLoad = 0;
        let targetLoad = 0;
        let loadHistory = [];
        let simulationIntervalDelay = 200;
        let messageAnimationInterval = null;
        
        // Step mode variables
        let stepMode = false;
        let stepQueue = [];
        let autoPlayInterval = null;
        
        // Migration tracking
        let currentMigrations = [];
        
        // Stats tracking
        let messageStats = {};
        let partitionLoadHistory = [];

        // Auto-scaling thresholds
        const SCALE_UP_THRESHOLD = 80;
        const SCALE_DOWN_THRESHOLD = 30;
        const MIN_PARTITIONS = 2;
        const MAX_PARTITIONS = 8;

        // Class to represent a partition
        class Partition {
            constructor(id) {
                this.id = id;
                this.name = `P${id}`;
                this.load = 0;
                this.slots = [];
                this.color = this.generateColor();
                this.messageCount = 0;
            }

            generateColor() {
                const colors = [
                    '#667eea', '#764ba2', '#00ff88', '#00cc70',
                    '#ffd93d', '#ff9800', '#ff6b6b', '#ff5252',
                    '#4ecdc4', '#44a3aa', '#95e1d3', '#6fcc7f'
                ];
                return colors[this.id % colors.length];
            }

            addSlot(slotId) {
                if (!this.slots.includes(slotId)) {
                    this.slots.push(slotId);
                }
            }

            removeSlot(slotId) {
                this.slots = this.slots.filter(s => s !== slotId);
            }
        }

        // Initialize the system
        function initializeSystem() {
            // Create slots
            for (let i = 0; i < TOTAL_SLOTS; i++) {
                slots.push({
                    id: i,
                    angle: (i * HASH_SPACE) / TOTAL_SLOTS,
                    active: true,
                    messageCount: 0
                });
            }

            // Create initial partitions
            for (let i = 0; i < 2; i++) {
                const partition = new Partition(nextPartitionId++);
                partitions.push(partition);
            }

            // Distribute slots to partitions
            distributeSlots();
            
            // Render the system
            renderHashRing();
            renderPartitionDistribution();
            updateSlotGrid();
            updateLoadMetrics();
            initializeStatsChart();
            
            logMessage('info', 'System initialized with 16 slots and 2 partitions');

            // Set initial speed value display
            document.getElementById('simulationSpeed').value = simulationIntervalDelay;
            updateSpeedDisplay(simulationIntervalDelay);
        }

        // Consistent hashing algorithm to distribute slots
        function distributeSlots() {
            slotToPartitionMap = {};
            
            // Reset partition slots
            partitions.forEach(p => p.slots = []);
            
            // Use a fair distribution algorithm
            const activePartitions = partitions.filter(p => p.id > 0);
            if (activePartitions.length === 0) return;
            
            slots.forEach((slot, index) => {
                const partitionIndex = index % activePartitions.length;
                const partition = activePartitions[partitionIndex];
                
                slotToPartitionMap[slot.id] = partition.id;
                partition.addSlot(slot.id);
            });
        }

        // Render the hash ring
        function renderHashRing() {
            const container = document.getElementById('consistent-hash-ring');
            container.querySelectorAll('.slot-node, .partition-node, .mapping-line').forEach(node => {
                if (node.id !== 'message-flow-indicator') {
                    node.remove();
                }
            });
            
            const centerX = 200;
            const centerY = 200;
            const radius = 150;
            const innerRadius = 100;
            
            // Draw slots on the outer ring
            slots.forEach(slot => {
                const angle = (slot.angle - 90) * Math.PI / 180;
                const x = centerX + radius * Math.cos(angle) - 22.5;
                const y = centerY + radius * Math.sin(angle) - 22.5;
                
                const slotNode = document.createElement('div');
                slotNode.className = `slot-node ${slot.active ? 'active' : 'inactive'}`;
                slotNode.style.left = x + 'px';
                slotNode.style.top = y + 'px';
                slotNode.textContent = `S${slot.id}`;
                slotNode.title = `Slot ${slot.id} - ${slot.messageCount} messages`;
                slotNode.onclick = () => showSlotDetails(slot.id);
                
                container.appendChild(slotNode);
            });
            
            // Draw partitions in the center
            partitions.forEach((partition, index) => {
                const angleStep = 360 / partitions.length;
                const angle = (index * angleStep - 90) * Math.PI / 180;
                const x = centerX + innerRadius * Math.cos(angle) - 25;
                const y = centerY + innerRadius * Math.sin(angle) - 25;
                
                const partitionNode = document.createElement('div');
                partitionNode.className = 'partition-node active';
                partitionNode.style.left = x + 'px';
                partitionNode.style.top = y + 'px';
                partitionNode.style.background = `linear-gradient(135deg, ${partition.color}, ${partition.color}dd)`;
                partitionNode.textContent = partition.name;
                partitionNode.title = `${partition.name} - ${partition.slots.length} slots, ${partition.messageCount} messages`;
                partitionNode.onclick = () => showPartitionDetails(partition.id);
                partitionNode.id = `partition-${partition.id}`;

                container.appendChild(partitionNode);
                
                // Draw mapping lines
                partition.slots.forEach(slotId => {
                    const slot = slots[slotId];
                    const slotAngle = (slot.angle - 90) * Math.PI / 180;
                    const slotX = centerX + radius * Math.cos(slotAngle);
                    const slotY = centerY + radius * Math.sin(slotAngle);
                    
                    const line = document.createElement('div');
                    line.className = 'mapping-line';
                    
                    const dx = slotX - (x + 25);
                    const dy = slotY - (y + 25);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const lineAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = distance + 'px';
                    line.style.left = (x + 25) + 'px';
                    line.style.top = (y + 25) + 'px';
                    line.style.transform = `rotate(${lineAngle}deg)`;
                    line.style.background = `linear-gradient(90deg, transparent, ${partition.color}88, transparent)`;
                    
                    container.appendChild(line);
                });
            });
            
            updateMetrics();
        }

        // Render partition distribution
        function renderPartitionDistribution() {
            const container = document.getElementById('partition-distribution');
            container.innerHTML = '';
            
            const barWidth = 30;
            const spacing = 10;
            const maxHeight = 250;
            
            partitions.forEach((partition, index) => {
                const x = index * (barWidth + spacing) + spacing;
                const height = (partition.slots.length / TOTAL_SLOTS) * maxHeight;
                
                const bar = document.createElement('div');
                bar.className = 'distribution-bar';
                bar.style.left = x + 'px';
                bar.style.width = barWidth + 'px';
                bar.style.height = height + 'px';
                bar.style.background = `linear-gradient(to top, ${partition.color}, ${partition.color}dd)`;
                bar.title = `${partition.name}: ${partition.slots.length} slots (${((partition.slots.length / TOTAL_SLOTS) * 100).toFixed(1)}%)`;
                bar.onclick = () => showPartitionDetails(partition.id);
                
                // Add text label on top
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.bottom = height + 5 + 'px';
                label.style.left = '50%';
                label.style.transform = 'translateX(-50%)';
                label.style.fontSize = '12px';
                label.style.color = partition.color;
                label.textContent = partition.slots.length;
                bar.appendChild(label);
                
                container.appendChild(bar);
            });
        }

        // Update slot grid
        function updateSlotGrid() {
            const grid = document.getElementById('slot-grid');
            grid.innerHTML = '';
            
            slots.forEach(slot => {
                const card = document.createElement('div');
                card.className = 'slot-card';
                card.id = `slot-card-${slot.id}`;
                const partitionId = slotToPartitionMap[slot.id];
                const partition = partitions.find(p => p.id === partitionId);
                
                if (partition) {
                    card.style.borderColor = partition.color + '44';
                    card.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 5px;">Slot ${slot.id}</div>
                        <div style="color: ${partition.color}; font-size: 0.9em;">${partition.name}</div>
                        <div style="font-size: 0.8em; color: #888; margin-top: 5px;">${slot.messageCount} msgs</div>
                    `;
                }
                
                grid.appendChild(card);
            });
        }

        // Add a partition
        function addPartition() {
            if (partitions.length >= MAX_PARTITIONS) {
                logMessage('error', 'Cannot add more partitions. Max limit reached.');
                showInfoTooltip(document.getElementById('addPartitionBtn'), 'Max partitions reached ('+MAX_PARTITIONS+')', 'error', 2500);
                return;
            }
            
            const newPartition = new Partition(nextPartitionId++);
            partitions.push(newPartition);
            
            logMessage('success', `New partition ${newPartition.name} added`);
            showInfoTooltip(document.getElementById('addPartitionBtn'), `Partition ${newPartition.name} added!`, 'success', 2500);

            if (stepMode) {
                stepQueue.push({
                    action: 'rebalance',
                    description: `Rebalancing slots after adding ${newPartition.name}`
                });
                logMessage('info', 'Step queued: Rebalance slots');
            } else {
                setTimeout(() => {
                    rebalanceSlots();
                }, 500 / getSpeedFactor());
            }
        }

        // Remove a partition
        function removePartition() {
            if (partitions.length <= MIN_PARTITIONS) {
                logMessage('error', `Cannot remove partition. Minimum ${MIN_PARTITIONS} required.`);
                showInfoTooltip(document.getElementById('removePartitionBtn'), `Minimum ${MIN_PARTITIONS} partitions required!`, 'error', 2500);
                return;
            }
            
            const removedPartition = partitions[partitions.length -1];
            partitions = partitions.filter(p => p.id !== removedPartition.id);

            logMessage('warning', `Partition ${removedPartition.name} removed, migration in progress...`);
            showInfoTooltip(document.getElementById('removePartitionBtn'), `Partition ${removedPartition.name} removed!`, 'warning', 2500);

            const partitionNodeToRemove = document.getElementById(`partition-${removedPartition.id}`);
            if (partitionNodeToRemove) {
                partitionNodeToRemove.classList.add('migrating');
            }
            
            if (stepMode) {
                stepQueue.push({
                    action: 'rebalance',
                    description: `Rebalancing slots after removing ${removedPartition.name}`
                });
                logMessage('info', 'Step queued: Rebalance slots');
            } else {
                setTimeout(() => {
                    rebalanceSlots();
                }, 1000 / getSpeedFactor());
            }
        }

        // Rebalance slots with migration tracking
        function rebalanceSlots() {
            logMessage('info', 'Rebalancing slots in progress...');
            showInfoTooltip(document.getElementById('rebalanceBtn'), 'Slots rebalancing...', 'info', 2500);

            const oldMap = {...slotToPartitionMap};
            currentMigrations = [];
            
            slotToPartitionMap = {};
            partitions.forEach(p => p.slots = []);
            
            const activePartitions = partitions.filter(p => p.id > 0);
            if (activePartitions.length === 0) return;
            
            const shuffledSlots = [...slots].sort(() => Math.random() - 0.5);
            
            shuffledSlots.forEach((slot, index) => {
                const partitionIndex = index % activePartitions.length;
                const partition = activePartitions[partitionIndex];
                
                slotToPartitionMap[slot.id] = partition.id;
                partition.addSlot(slot.id);
            });
            
            // Track migrations
            let migrationCount = 0;
            const ringSlotNodes = document.querySelectorAll('#consistent-hash-ring .slot-node');

            Object.keys(oldMap).forEach(slotId => {
                const currentPartitionId = slotToPartitionMap[slotId];
                const oldPartitionId = oldMap[slotId];
                if (currentPartitionId !== oldPartitionId) {
                    migrationCount++;
                    
                    const oldPartition = partitions.find(p => p.id === oldPartitionId);
                    const newPartition = partitions.find(p => p.id === currentPartitionId);
                    
                    currentMigrations.push({
                        slotId: parseInt(slotId),
                        from: oldPartition ? oldPartition.name : 'Unknown',
                        to: newPartition ? newPartition.name : 'Unknown'
                    });
                    
                    const slotNode = ringSlotNodes[slotId];
                    if (slotNode) {
                        slotNode.classList.add('migrating-flash');
                        setTimeout(() => {
                            slotNode.classList.remove('migrating-flash');
                        }, 600 / getSpeedFactor());
                    }
                }
            });
            
            if (migrationCount > 0) {
                showMigrationInfo();
            }
            
            setTimeout(() => {
                renderHashRing();
                renderPartitionDistribution();
                updateSlotGrid();
                updateStatsChart();
            }, 300 / getSpeedFactor());
            
            logMessage('success', `Rebalancing completed: ${migrationCount} slots migrated`);
        }

        // Show migration information
        function showMigrationInfo() {
            const migrationInfo = document.getElementById('migrationInfo');
            const migrationDetails = document.getElementById('migrationDetails');
            
            migrationInfo.classList.add('active');
            
            let detailsHTML = '<ul style="margin: 10px 0; padding-left: 20px;">';
            currentMigrations.forEach(migration => {
                detailsHTML += `<li>Slot ${migration.slotId}: ${migration.from} ‚Üí ${migration.to}</li>`;
            });
            detailsHTML += '</ul>';
            
            migrationDetails.innerHTML = detailsHTML;
            
            setTimeout(() => {
                migrationInfo.classList.remove('active');
            }, 3000 / getSpeedFactor());
        }

        // Test hash function
        function testHash() {
            const input = document.getElementById('hashTestInput').value.trim();
            if (!input) {
                showInfoTooltip(document.getElementById('hashTestInput'), 'Please enter a message key', 'warning', 2000);
                return;
            }
            
            const hash = hashFunction(input);
            const slotId = hash % TOTAL_SLOTS;
            const partitionId = slotToPartitionMap[slotId];
            const partition = partitions.find(p => p.id === partitionId);
            
            const resultDiv = document.getElementById('hashTestResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <h4 style="color: #00ff88; margin-bottom: 10px;">Hash Result for "${input}"</h4>
                <div class="metric">
                    <span class="metric-label">Hash Value</span>
                    <span class="metric-value">${hash}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Slot Assignment</span>
                    <span class="metric-value">Slot ${slotId}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Target Partition</span>
                    <span class="metric-value" style="color: ${partition ? partition.color : '#888'}">${partition ? partition.name : 'Unknown'}</span>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(0, 255, 136, 0.1); border-radius: 8px;">
                    <strong>Path:</strong> "${input}" ‚Üí Hash(${hash}) ‚Üí Slot ${slotId} ‚Üí ${partition ? partition.name : 'Unknown'}
                </div>
            `;
            
            // Animate the path
            const slotNode = document.querySelector(`#consistent-hash-ring .slot-node:nth-child(${slotId + 1})`);
            if (slotNode) {
                slotNode.classList.add('highlighted');
                setTimeout(() => {
                    slotNode.classList.remove('highlighted');
                }, 1000);
            }
            
            if (partition) {
                const partitionNode = document.getElementById(`partition-${partition.id}`);
                if (partitionNode) {
                    partitionNode.classList.add('highlight-pulse');
                    setTimeout(() => {
                        partitionNode.classList.remove('highlight-pulse');
                    }, 1000);
                }
            }
            
            logMessage('info', `Hash test: "${input}" ‚Üí Slot ${slotId} ‚Üí ${partition ? partition.name : 'Unknown'}`);
        }

        // Show hash test modal
        function showHashTest() {
            document.getElementById('hashTestInput').focus();
        }

        // Toggle step mode
        function toggleStepMode() {
            stepMode = !stepMode;
            const stepControls = document.getElementById('stepControls');
            
            if (stepMode) {
                stepControls.style.display = 'block';
                logMessage('warning', 'Step-by-step mode activated. Use controls to advance.');
                showInfoTooltip(document.querySelector('[onclick="toggleStepMode()"]'), 'Step mode ON', 'warning', 2000);
            } else {
                stepControls.style.display = 'none';
                stepQueue = [];
                if (autoPlayInterval) {
                    clearInterval(autoPlayInterval);
                    autoPlayInterval = null;
                }
                logMessage('info', 'Step-by-step mode deactivated.');
                showInfoTooltip(document.querySelector('[onclick="toggleStepMode()"]'), 'Step mode OFF', 'info', 2000);
            }
        }

        // Execute next step
        function nextStep() {
            if (stepQueue.length === 0) {
                logMessage('info', 'No pending steps. Perform an action to queue steps.');
                return;
            }
            
            const step = stepQueue.shift();
            logMessage('info', `Executing: ${step.description}`);
            
            switch(step.action) {
                case 'rebalance':
                    rebalanceSlots();
                    break;
                case 'generate':
                    generateMessage();
                    break;
            }
        }

        // Auto play steps
        function autoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                logMessage('info', 'Auto-play stopped');
            } else {
                logMessage('info', 'Auto-play started');
                autoPlayInterval = setInterval(() => {
                    if (stepQueue.length > 0) {
                        nextStep();
                    }
                }, 1000 / getSpeedFactor());
            }
        }

        // Initialize stats chart
        function initializeStatsChart() {
            updateStatsChart();
        }

        // Update stats chart
        function updateStatsChart() {
            const container = document.getElementById('chartContainer');
            container.innerHTML = '';
            
            const maxBars = 30;
            const barWidth = container.offsetWidth / maxBars;
            
            // Add current partition loads to history
            const currentLoads = partitions.map(p => ({
                id: p.id,
                load: p.slots.length,
                color: p.color
            }));
            
            partitionLoadHistory.push(currentLoads);
            if (partitionLoadHistory.length > maxBars) {
                partitionLoadHistory.shift();
            }
            
            // Render history
            partitionLoadHistory.forEach((loads, timeIndex) => {
                let yOffset = 0;
                loads.forEach(partitionLoad => {
                    const height = (partitionLoad.load / TOTAL_SLOTS) * 100;
                    const bar = document.createElement('div');
                    bar.style.position = 'absolute';
                    bar.style.left = (timeIndex * barWidth) + 'px';
                    bar.style.bottom = yOffset + '%';
                    bar.style.width = (barWidth - 1) + 'px';
                    bar.style.height = height + '%';
                    bar.style.background = partitionLoad.color;
                    bar.style.opacity = '0.8';
                    container.appendChild(bar);
                    yOffset += height;
                });
            });
        }

        // Simulate load with auto-scaling
        function simulateLoad() {
            const simulateLoadBtn = document.getElementById('simulateLoadBtn');
            if (loadSimulationInterval) {
                clearInterval(loadSimulationInterval);
                loadSimulationInterval = null;
                logMessage('info', 'Load simulation stopped');
                simulateLoadBtn.textContent = 'üìä Auto-Scaling Demo';
                showInfoTooltip(simulateLoadBtn, 'Load simulation stopped', 'info', 2500);

                const decreaseInterval = setInterval(() => {
                    targetLoad = Math.max(0, targetLoad - 5);
                    currentLoad = currentLoad * 0.7 + targetLoad * 0.3;
                    if (targetLoad <= 0.1 && currentLoad <= 0.1) {
                        clearInterval(decreaseInterval);
                        currentLoad = 0;
                        updateLoadVisualization();
                        updateLoadMetrics();
                        stopMessageAnimation();
                    } else {
                        updateLoadVisualization();
                        updateLoadMetrics();
                    }
                }, simulationIntervalDelay);
                return;
            }
            
            logMessage('info', 'Starting load simulation with auto-scaling...');
            simulateLoadBtn.textContent = '‚èπÔ∏è Stop Demo';
            showInfoTooltip(simulateLoadBtn, 'Auto-scaling simulation started!', 'success', 2500);
            startMessageAnimation();

            let phase = 0;
            loadSimulationInterval = setInterval(() => {
                phase++;
                
                if (phase < 20) {
                    targetLoad = Math.min(100, targetLoad + 10);
                } else if (phase < 40) {
                    targetLoad = 90 + Math.random() * 10;
                } else if (phase < 60) {
                    targetLoad = Math.max(20, targetLoad - 5);
                } else if (phase < 80) {
                    targetLoad = 20 + Math.random() * 20;
                } else {
                    phase = 0;
                }
                
                currentLoad = currentLoad * 0.7 + targetLoad * 0.3;
                
                const messageRate = Math.floor(currentLoad / 10);
                for (let i = 0; i < messageRate; i++) {
                    if (stepMode) {
                        stepQueue.push({
                            action: 'generate',
                            description: 'Generate message based on load'
                        });
                    } else {
                        generateMessage();
                    }
                }
                
                loadHistory.push(currentLoad);
                if (loadHistory.length > 50) loadHistory.shift();
                
                checkAutoScaling();
                updateLoadMetrics();
                updateLoadVisualization();
                
            }, simulationIntervalDelay);
        }
        
        // Generate a message and track load
        function generateMessage() {
            const key = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const hash = hashFunction(key);
            const slotId = hash % TOTAL_SLOTS;
            const partitionId = slotToPartitionMap[slotId];
            const partition = partitions.find(p => p.id === partitionId);
            
            if (partition) {
                partition.load++;
                partition.messageCount++;
                slots[slotId].messageCount++;
                
                const slotNode = document.querySelector(`#consistent-hash-ring .slot-node:nth-child(${slotId + 1})`);
                if (slotNode) {
                    slotNode.classList.add('highlighted');
                    setTimeout(() => {
                        slotNode.classList.remove('highlighted');
                    }, 300 / getSpeedFactor());
                }

                const partitionNode = document.getElementById(`partition-${partition.id}`);
                if (partitionNode) {
                    partitionNode.classList.add('highlight-pulse');
                    setTimeout(() => {
                        partitionNode.classList.remove('highlight-pulse');
                    }, 600 / getSpeedFactor());
                }

                const messageFlowIndicator = document.getElementById('message-flow-indicator');
                if (messageFlowIndicator) {
                    const slot = slots[slotId];
                    const targetAngle = slot.angle;
                    messageFlowIndicator.style.transform = `translate(-50%, -50%) rotate(${targetAngle}deg)`;
                    messageFlowIndicator.classList.add('active');
                    setTimeout(() => {
                        messageFlowIndicator.classList.remove('active');
                    }, 500 / getSpeedFactor());
                }
                
                // Update slot card
                const slotCard = document.getElementById(`slot-card-${slotId}`);
                if (slotCard) {
                    slotCard.classList.add('highlighted');
                    setTimeout(() => {
                        slotCard.classList.remove('highlighted');
                        updateSlotGrid();
                    }, 300 / getSpeedFactor());
                }
            }
        }
        
        // Check if auto-scaling is needed
        function checkAutoScaling() {
            const avgLoad = currentLoad;
            const currentPartitionCount = partitions.length;
            
            if (avgLoad > SCALE_UP_THRESHOLD && currentPartitionCount < MAX_PARTITIONS) {
                const newPartition = new Partition(nextPartitionId++);
                partitions.push(newPartition);
                logMessage('warning', `High load detected (${avgLoad.toFixed(1)}%). Scaling up to ${partitions.length} partitions`);
                showInfoTooltip(document.getElementById('simulateLoadBtn'), `Scaling UP! ${newPartition.name} added.`, 'warning', 2500);

                setTimeout(() => {
                    rebalanceSlots();
                }, 500 / getSpeedFactor());
                
            } else if (avgLoad < SCALE_DOWN_THRESHOLD && currentPartitionCount > MIN_PARTITIONS) {
                const removedPartition = partitions[partitions.length -1];
                partitions = partitions.filter(p => p.id !== removedPartition.id);

                logMessage('info', `Low load detected (${avgLoad.toFixed(1)}%). Scaling down to ${partitions.length} partitions`);
                showInfoTooltip(document.getElementById('simulateLoadBtn'), `Scaling DOWN! ${removedPartition.name} removed.`, 'info', 2500);

                const partitionNodeToRemove = document.getElementById(`partition-${removedPartition.id}`);
                if (partitionNodeToRemove) {
                    partitionNodeToRemove.classList.add('migrating');
                }
                
                setTimeout(() => {
                    rebalanceSlots();
                }, 1000 / getSpeedFactor());
            }
        }
        
        // Update load visualization
        function updateLoadVisualization() {
            let loadBar = document.getElementById('load-indicator');
            if (!loadBar) {
                const controlsDiv = document.querySelector('.controls');
                const loadContainer = document.createElement('div');
                loadContainer.innerHTML = `
                    <div style="margin: 20px 0;">
                        <h4 style="margin-bottom: 10px; color: #667eea;">System Load</h4>
                        <div style="background: rgba(255,255,255,0.1); border-radius: 10px; height: 30px; position: relative; overflow: hidden;">
                            <div id="load-indicator" style="
                                position: absolute;
                                left: 0;
                                top: 0;
                                height: 100%;
                                background: linear-gradient(90deg, #00ff88, #667eea);
                                transition: width 0.3s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                color: white;
                                font-weight: bold;
                            ">0%</div>
                            <div style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: #888; font-size: 0.9em;">
                                Auto-scale: ${SCALE_DOWN_THRESHOLD}% ‚Üì | ${SCALE_UP_THRESHOLD}% ‚Üë
                            </div>
                        </div>
                    </div>
                `;
                controlsDiv.insertAdjacentElement('afterend', loadContainer);
                loadBar = document.getElementById('load-indicator');
            }
            
            loadBar.style.width = currentLoad + '%';
            loadBar.textContent = currentLoad.toFixed(1) + '%';
            
            if (currentLoad > SCALE_UP_THRESHOLD) {
                loadBar.style.background = 'linear-gradient(90deg, #ff6b6b, #ff5252)';
            } else if (currentLoad < SCALE_DOWN_THRESHOLD) {
                loadBar.style.background = 'linear-gradient(90deg, #4ecdc4, #44a3aa)';
            } else {
                loadBar.style.background = 'linear-gradient(90deg, #00ff88, #667eea)';
            }
        }
        
        // Update load metrics
        function updateLoadMetrics() {
            document.getElementById('total-slots').textContent = TOTAL_SLOTS;
            document.getElementById('active-partitions').textContent = partitions.length;
            document.getElementById('replication-factor').textContent = '3';
            
            let loadMetric = document.getElementById('current-load-metric');
            if (!loadMetric) {
                const metricsContainer = document.querySelector('.slot-details');
                const loadDiv = document.createElement('div');
                loadDiv.className = 'metric';
                loadDiv.innerHTML = `
                    <span class="metric-label">Current Load</span>
                    <span class="metric-value" id="current-load-metric">0%</span>
                `;
                metricsContainer.appendChild(loadDiv);
                loadMetric = document.getElementById('current-load-metric');
            }
            
            loadMetric.textContent = currentLoad.toFixed(1) + '%';
            
            // Add total messages metric if not exists
            let totalMessagesMetric = document.getElementById('total-messages-metric');
            if (!totalMessagesMetric) {
                const metricsContainer = document.querySelector('.slot-details');
                const messagesDiv = document.createElement('div');
                messagesDiv.className = 'metric';
                messagesDiv.innerHTML = `
                    <span class="metric-label">Total Messages</span>
                    <span class="metric-value" id="total-messages-metric">0</span>
                `;
                metricsContainer.appendChild(messagesDiv);
                totalMessagesMetric = document.getElementById('total-messages-metric');
            }
            
            const totalMessages = partitions.reduce((sum, p) => sum + p.messageCount, 0);
            totalMessagesMetric.textContent = totalMessages;
        }

        // Simple hash function
        function hashFunction(key) {
            let hash = 0;
            for (let i = 0; i < key.length; i++) {
                const char = key.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // Show slot details
        function showSlotDetails(slotId) {
            const slot = slots[slotId];
            const partitionId = slotToPartitionMap[slotId];
            const partition = partitions.find(p => p.id === partitionId);
            
            const modal = document.getElementById('infoModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `Slot ${slotId} Details`;
            modalBody.innerHTML = `
                <div class="metric">
                    <span class="metric-label">Slot ID</span>
                    <span class="metric-value">${slotId}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Hash Position</span>
                    <span class="metric-value">${slot.angle}¬∞</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Assigned Partition</span>
                    <span class="metric-value" style="color: ${partition ? partition.color : '#888'}">${partition ? partition.name : 'Unassigned'}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Messages Processed</span>
                    <span class="metric-value">${slot.messageCount}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value">${slot.active ? 'Active' : 'Inactive'}</span>
                </div>
                <div style="margin-top: 20px;">
                    <h4>How Slot Mapping Works</h4>
                    <p style="color: #888; line-height: 1.6;">
                        Slot ${slotId} is a fixed point on the hash ring at position ${slot.angle}¬∞. 
                        When a message is hashed, if the result modulo ${TOTAL_SLOTS} equals ${slotId}, 
                        it will be routed to this slot. The slot then forwards the message to its 
                        assigned partition (currently ${partition ? partition.name : 'none'}).
                    </p>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 10px; margin-top: 15px;">
                        <strong>Example:</strong><br>
                        Hash("user_123") = 98765<br>
                        98765 % 16 = ${slotId}<br>
                        ‚Üí Route to Slot ${slotId} ‚Üí ${partition ? partition.name : 'Unassigned'}
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }

        // Show partition details
        function showPartitionDetails(partitionId) {
            const partition = partitions.find(p => p.id === partitionId);
            if (!partition) return;

            const modal = document.getElementById('infoModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `Partition ${partition.name} Details`;
            modalBody.innerHTML = `
                <div class="metric">
                    <span class="metric-label">Name</span>
                    <span class="metric-value">${partition.name}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Managed Slots</span>
                    <span class="metric-value">${partition.slots.length} / ${TOTAL_SLOTS}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Messages Processed</span>
                    <span class="metric-value">${partition.messageCount}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Ring Percentage</span>
                    <span class="metric-value">${((partition.slots.length / TOTAL_SLOTS) * 100).toFixed(1)}%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Avg Messages/Slot</span>
                    <span class="metric-value">${partition.slots.length > 0 ? (partition.messageCount / partition.slots.length).toFixed(2) : 0}</span>
                </div>
                <div style="margin-top: 20px;">
                    <h4>Assigned Slots</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px;">
                        ${partition.slots.map(slotId => {
                            const slotMessages = slots[slotId].messageCount;
                            return `<span style="background: ${partition.color}44; padding: 5px 10px; border-radius: 5px; font-size: 0.9em;">
                                Slot ${slotId} (${slotMessages} msgs)
                            </span>`;
                        }).join('')}
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h4>Load Distribution Benefits</h4>
                    <p style="color: #888; line-height: 1.6;">
                        With consistent hashing and slot-based mapping, this partition can be:
                    </p>
                    <ul style="color: #888; line-height: 1.8; margin-left: 20px;">
                        <li>Added or removed without rehashing all data</li>
                        <li>Scaled independently based on load</li>
                        <li>Replicated for fault tolerance</li>
                        <li>Migrated to different hardware seamlessly</li>
                    </ul>
                </div>
            `;
            
            modal.style.display = 'flex';
        }

        // Show system information
        function showSystemInfo() {
            const modal = document.getElementById('infoModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = 'StreamFlow Architecture - Complete Guide';
            modalBody.innerHTML = `
                <h3 style="color: #667eea; margin-bottom: 15px;">üéØ Core Concepts</h3>
                <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="color: #00ff88;">1. Consistent Hashing</h4>
                    <p style="color: #888; line-height: 1.6;">
                        Maps data to a fixed-size hash space (ring). Each key is hashed to a position 
                        on the ring, ensuring even distribution and minimal redistribution when nodes change.
                    </p>
                </div>
                
                <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="color: #00ff88;">2. Slot-Based Mapping</h4>
                    <p style="color: #888; line-height: 1.6;">
                        The hash ring is divided into fixed slots (16 in this demo). Messages are 
                        assigned to slots, not directly to partitions. This indirection enables:
                    </p>
                    <ul style="color: #888; margin-left: 20px;">
                        <li>Zero-downtime scaling</li>
                        <li>Predictable data distribution</li>
                        <li>Simple rebalancing logic</li>
                    </ul>
                </div>
                
                <h3 style="color: #667eea; margin-bottom: 15px; margin-top: 30px;">üìä How It Works</h3>
                <div style="background: rgba(0, 255, 136, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <ol style="color: #888; line-height: 1.8; margin-left: 20px;">
                        <li><strong>Message arrives:</strong> "order_12345"</li>
                        <li><strong>Hash calculated:</strong> Hash("order_12345") = 98765</li>
                        <li><strong>Slot determined:</strong> 98765 % 16 = 5</li>
                        <li><strong>Partition lookup:</strong> Slot 5 ‚Üí Partition P2</li>
                        <li><strong>Message routed:</strong> Send to Partition P2</li>
                    </ol>
                </div>
                
                <h3 style="color: #667eea; margin-bottom: 15px;">üîÑ Elastic Scaling Process</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div style="background: rgba(255, 215, 61, 0.1); padding: 10px; border-radius: 8px;">
                        <strong style="color: #ffd93d;">Scale Up</strong><br>
                        <span style="color: #888; font-size: 0.9em;">
                            1. Add new partition<br>
                            2. Redistribute slots evenly<br>
                            3. Migrate affected data<br>
                            4. Update routing table
                        </span>
                    </div>
                    <div style="background: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 8px;">
                        <strong style="color: #ff6b6b;">Scale Down</strong><br>
                        <span style="color: #888; font-size: 0.9em;">
                            1. Select partition to remove<br>
                            2. Redistribute its slots<br>
                            3. Migrate data to remaining<br>
                            4. Decommission partition
                        </span>
                    </div>
                </div>
                
                <h3 style="color: #667eea; margin-bottom: 15px; margin-top: 30px;">üí° Key Benefits</h3>
                <div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 10px;">
                    <p style="color: #888; line-height: 1.8;">
                        <strong>‚úì Minimal Data Movement:</strong> Only ~1/N of data moves when adding/removing nodes<br>
                        <strong>‚úì No Downtime:</strong> Clients continue using the same slot addresses<br>
                        <strong>‚úì Load Balancing:</strong> Even distribution across all partitions<br>
                        <strong>‚úì Fault Tolerance:</strong> Easy replication at the slot level<br>
                        <strong>‚úì Predictable Performance:</strong> Consistent routing overhead
                    </p>
                </div>
            `;
            
            modal.style.display = 'flex';
        }

        // Toggle animation
        function toggleAnimation() {
            animationRunning = !animationRunning;
            if (animationRunning) {
                logMessage('info', 'Animations enabled');
                startMessageAnimation();
            } else {
                logMessage('info', 'Animations disabled');
                stopMessageAnimation();
            }
        }

        // Log a message
        function logMessage(type, message) {
            const logContainer = document.getElementById('log-container');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            
            logContainer.insertBefore(logEntry, logContainer.firstChild);
            
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Update metrics
        function updateMetrics() {
            document.getElementById('total-slots').textContent = TOTAL_SLOTS;
            document.getElementById('active-partitions').textContent = partitions.length;
            document.getElementById('replication-factor').textContent = '3';
            updateLoadMetrics();
        }

        // Close modal
        function closeModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('infoModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Speed Control Functions
        function setSimulationSpeed(value) {
            simulationIntervalDelay = parseInt(value);
            updateSpeedDisplay(value);

            if (loadSimulationInterval) {
                clearInterval(loadSimulationInterval);
                simulateLoad();
            }
            if (messageAnimationInterval) {
                clearInterval(messageAnimationInterval);
                startMessageAnimation();
            }
        }

        function getSpeedFactor() {
            return 200 / simulationIntervalDelay;
        }

        function updateSpeedDisplay(value) {
            const referenceInterval = 200;
            const currentInterval = parseInt(value);
            let speedFactor;

            if (currentInterval === 0) {
                speedFactor = Infinity;
            } else {
                speedFactor = referenceInterval / currentInterval;
            }
            
            let displayText = speedFactor.toFixed(1) + 'x';
            if (speedFactor > 10) displayText = 'Max Speed';
            if (speedFactor < 0.1) displayText = 'Min Speed';

            document.getElementById('speedValue').textContent = displayText;
        }

        // Periodic message animation
        function animateMessages() {
            if (!animationRunning) return;
            if (loadSimulationInterval) return;
            
            const slotsNodes = document.querySelectorAll('.slot-node.active');
            if (slotsNodes.length > 0) {
                const randomSlotNode = slotsNodes[Math.floor(Math.random() * slotsNodes.length)];
                const slotId = parseInt(randomSlotNode.textContent.replace('S', ''));
                const partitionId = slotToPartitionMap[slotId];
                const partition = partitions.find(p => p.id === partitionId);
                const partitionNode = partition ? document.getElementById(`partition-${partition.id}`) : null;

                randomSlotNode.classList.add('highlighted');
                setTimeout(() => {
                    randomSlotNode.classList.remove('highlighted');
                }, 300 / getSpeedFactor());
                
                if (partitionNode) {
                    partitionNode.classList.add('highlight-pulse');
                    setTimeout(() => {
                        partitionNode.classList.remove('highlight-pulse');
                    }, 600 / getSpeedFactor());
                }

                const messageFlowIndicator = document.getElementById('message-flow-indicator');
                if (messageFlowIndicator) {
                    const slot = slots[slotId];
                    messageFlowIndicator.style.transform = `translate(-50%, -50%) rotate(${slot.angle}deg)`;
                    messageFlowIndicator.classList.add('active');
                    setTimeout(() => {
                        messageFlowIndicator.classList.remove('active');
                    }, 500 / getSpeedFactor());
                }
            }
        }

        function startMessageAnimation() {
            if (messageAnimationInterval) {
                clearInterval(messageAnimationInterval);
            }
            messageAnimationInterval = setInterval(() => {
                animateMessages();
            }, 2000 / getSpeedFactor());
        }

        function stopMessageAnimation() {
            if (messageAnimationInterval) {
                clearInterval(messageAnimationInterval);
                messageAnimationInterval = null;
            }
        }

        // Info Tooltip Functionality
        const infoTooltip = document.getElementById('infoTooltip');
        let tooltipTimeout;

        function showInfoTooltip(element, message, type = 'info', duration = 2500) {
            if (!animationRunning) return;

            clearTimeout(tooltipTimeout);

            infoTooltip.textContent = message;
            infoTooltip.className = `info-tooltip show ${type}`;
            
            const rect = element.getBoundingClientRect();
            const controlsRect = element.closest('.controls').getBoundingClientRect();

            infoTooltip.style.left = `${rect.left - controlsRect.left + rect.width / 2}px`;
            infoTooltip.style.bottom = `${controlsRect.bottom - rect.top + rect.height + 10}px`;

            infoTooltip.style.transition = 'none';
            infoTooltip.style.transform = 'translate(-50%, 10px)';
            infoTooltip.style.opacity = '0';
            
            void infoTooltip.offsetWidth;

            infoTooltip.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            infoTooltip.style.transform = 'translate(-50%, 0)';
            infoTooltip.style.opacity = '1';
            
            tooltipTimeout = setTimeout(() => {
                infoTooltip.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                infoTooltip.style.opacity = '0';
                infoTooltip.style.transform = 'translate(-50%, -10px)';
            }, duration / getSpeedFactor());
        }

        // Tutorial Overlay Functionality
        function showTutorial() {
            const tutorialOverlay = document.getElementById('tutorialOverlay');
            tutorialOverlay.style.display = 'flex';
        }

        function hideTutorial(event) {
            // Prevent hiding if clicking the button (it will be handled by the button's onclick)
            if (event && event.target && event.target.tagName === 'BUTTON') {
                event.stopPropagation();
            }
            
            const tutorialOverlay = document.getElementById('tutorialOverlay');
            tutorialOverlay.style.display = 'none';
            
            // Try to save tutorial state, but handle sandboxed environments
            try {
                localStorage.setItem('streamflowTutorialShown', 'true');
            } catch (e) {
                // Silently fail if localStorage is not available (sandboxed environment)
                console.log('localStorage not available in sandboxed environment');
            }
        }

        // Initialize system on load
        window.onload = function() {
            initializeSystem();
            startMessageAnimation();
            
            // Check for tutorial with error handling for sandboxed environments
            try {
                if (!localStorage.getItem('streamflowTutorialShown')) {
                    showTutorial();
                }
            } catch (e) {
                // Show tutorial in sandboxed environments (can't remember preference)
                showTutorial();
            }
            
            // Add enter key support for hash test
            document.getElementById('hashTestInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    testHash();
                }
            });
        }
    </script>
</body>
</html>
